// MIT/Apache2 License
// This file was automatically generated by bindgen and modified by me, not_a_seagull

use winapi::shared::{minwindef::ULONG_PTR, windef::HDC};

#[doc = "! Basic four-element color."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDIPColor {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_GDIPColor() {
    assert_eq!(
        ::core::mem::size_of::<GDIPColor>(),
        4usize,
        concat!("Size of: ", stringify!(GDIPColor))
    );
    assert_eq!(
        ::core::mem::align_of::<GDIPColor>(),
        1usize,
        concat!("Alignment of ", stringify!(GDIPColor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPColor>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPColor>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPColor>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPColor),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPColor>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPColor),
            "::",
            stringify!(a)
        )
    );
}
#[doc = "! A graphics object is designed primarily as a pointer to the native graphics"]
#[doc = "! object, as well as a result. We can have both of these."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDIPGraphics {
    pub native_graphics: *mut ::core::ffi::c_void,
    pub last_status: isize,
}
#[test]
fn bindgen_test_layout_GDIPGraphics() {
    assert_eq!(
        ::core::mem::size_of::<GDIPGraphics>(),
        16usize,
        concat!("Size of: ", stringify!(GDIPGraphics))
    );
    assert_eq!(
        ::core::mem::align_of::<GDIPGraphics>(),
        8usize,
        concat!("Alignment of ", stringify!(GDIPGraphics))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPGraphics>())).native_graphics as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPGraphics),
            "::",
            stringify!(native_graphics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPGraphics>())).last_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPGraphics),
            "::",
            stringify!(last_status)
        )
    );
}
#[doc = "! A pen is designed in a similar manner."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDIPPen {
    pub native_pen: *mut ::core::ffi::c_void,
    pub last_status: isize,
}
#[test]
fn bindgen_test_layout_GDIPPen() {
    assert_eq!(
        ::core::mem::size_of::<GDIPPen>(),
        16usize,
        concat!("Size of: ", stringify!(GDIPPen))
    );
    assert_eq!(
        ::core::mem::align_of::<GDIPPen>(),
        8usize,
        concat!("Alignment of ", stringify!(GDIPPen))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPPen>())).native_pen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPPen),
            "::",
            stringify!(native_pen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPPen>())).last_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPPen),
            "::",
            stringify!(last_status)
        )
    );
}
#[doc = "! Same with the brush."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDIPBrush {
    pub native_brush: *mut ::core::ffi::c_void,
    pub last_status: isize,
}
#[test]
fn bindgen_test_layout_GDIPBrush() {
    assert_eq!(
        ::core::mem::size_of::<GDIPBrush>(),
        16usize,
        concat!("Size of: ", stringify!(GDIPBrush))
    );
    assert_eq!(
        ::core::mem::align_of::<GDIPBrush>(),
        8usize,
        concat!("Alignment of ", stringify!(GDIPBrush))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPBrush>())).native_brush as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPBrush),
            "::",
            stringify!(native_brush)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GDIPBrush>())).last_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDIPBrush),
            "::",
            stringify!(last_status)
        )
    );
}
extern "C" {
    #[doc = "! Initialize the GDI, returns a startup token."]
    pub fn initialize_gdiplus(startup_token: *mut ULONG_PTR);
}
extern "C" {
    #[doc = "! Uninitialize the GDI, given the startup token."]
    pub fn done_gdiplus(startup_token: ULONG_PTR);
}
extern "C" {
    #[doc = "! Get a pointer to the last thing that went wrong, if applicable."]
    pub fn err_pointer() -> *const cty::c_char;
}
extern "C" {
    #[doc = "! Create a GDIPlus graphics item from an HDC."]
    pub fn from_hdc(hDC: HDC, graphics: *mut GDIPGraphics) -> cty::c_int;
}
extern "C" {
    #[doc = "! Dealloc a GDIPlus graphics instance."]
    pub fn done_graphics(graphics: GDIPGraphics);
}
extern "C" {
    #[doc = "! Create a new pen from a color and a width."]
    pub fn create_pen(color: GDIPColor, width: u32, pen: *mut GDIPPen) -> cty::c_int;
}
extern "C" {
    #[doc = "! Dealloc a pen."]
    pub fn done_pen(pen: GDIPPen);
}
extern "C" {
    #[doc = "! Create a new brush from a color."]
    pub fn create_brush(color: GDIPColor, brush: *mut GDIPBrush) -> cty::c_int;
}
extern "C" {
    #[doc = "! Dealloc a brush."]
    pub fn done_brush(brush: GDIPBrush);
}
extern "C" {
    #[doc = "! Draw a line from one point to another."]
    pub fn draw_line(
        graphics: *mut GDIPGraphics,
        pen: *const GDIPPen,
        x1: cty::c_int,
        y1: cty::c_int,
        x2: cty::c_int,
        y2: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "! Draw a rectangle."]
    pub fn draw_rectangle(
        graphics: *mut GDIPGraphics,
        pen: *const GDIPPen,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "! Draw an arc."]
    pub fn draw_arc(
        graphics: *mut GDIPGraphics,
        pen: *const GDIPPen,
        rectleft: cty::c_int,
        recttop: cty::c_int,
        rectwidth: cty::c_uint,
        rectheight: cty::c_uint,
        start_angle: f32,
        end_angle: f32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "! Draw an ellipse."]
    pub fn draw_ellipse(
        graphics: *mut GDIPGraphics,
        pen: *const GDIPPen,
        rectleft: cty::c_int,
        recttop: cty::c_int,
        rectwidth: cty::c_uint,
        rectheight: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "! Fill a rectangle."]
    pub fn fill_rectangle(
        graphics: *mut GDIPGraphics,
        brush: *const GDIPBrush,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "! Fill an arc."]
    pub fn fill_arc(
        graphics: *mut GDIPGraphics,
        brush: *const GDIPBrush,
        rectleft: cty::c_int,
        recttop: cty::c_int,
        rectwidth: cty::c_uint,
        rectheight: cty::c_uint,
        start_angle: f32,
        end_angle: f32,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "! Fill an ellispe."]
    pub fn fill_ellipse(
        graphics: *mut GDIPGraphics,
        brush: *const GDIPBrush,
        rectleft: cty::c_int,
        recttop: cty::c_int,
        rectwidth: cty::c_uint,
        rectheight: cty::c_uint,
    ) -> cty::c_int;
}
pub type __builtin_va_list = *mut cty::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {
    pub _address: u8,
}
